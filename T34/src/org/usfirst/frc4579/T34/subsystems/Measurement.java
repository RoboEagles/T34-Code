// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4579.T34.subsystems;

import org.usfirst.frc4579.T34.RobotMap;
import org.usfirst.frc4579.T34.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.interfaces.Accelerometer;


/**
 *
 */
public class Measurement extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    Gyro gyro = RobotMap.measurementGyro;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private Accelerometer robotAccelerometer = RobotMap.robotAccelerometer;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new Accumulate());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    //Measurement Variables
    private static double delayTime = 1.0; // Changing this would mean rewriting some of the code to calculate degrees per second
    private Timer timer = new Timer();
    private boolean validity = false;
    private String forwardAccelAxis = "Y",   // Default is Y ALL CALCULATIONS FOR FORWARD ACCEL WILL BE IN TERMS OF Y
    			   sidewaysAccelAxis = "X";  // Default is X ALL CALCULATIONS FOR SIDEWAYS ACCEL WILL BE IN TERMS OF X
    private static final double GtoInches = 386.088; // Gs to Inches / sec / sec
    
    //Error Accumulation Variables
    private double gyroDriftRate,
    			   accelerometerXBias, // THESE BIASES ARE PHYSICAL AXIS NOT FIELD ORIENTED AXIS
    			   accelerometerYBias, // E.G. THE YBias IS THE BIAS ON accelerometer.getY()
    			   accelerometerZBias,
    			   lastTime;
    
    //Accumulating Variables
    private double distanceTravelled = 0.,  // TOTAL DISTANCE TRAVELLED
    			   distanceTravelledY = 0., // DISTANCE TRAVELLED FORWARD (DOWNRANGE)
    			   distanceTravelledX = 0., // DISTANCE TRAVELLED SIDEWAYS
    			   velocity = 0.,
    			   gyroAngle = 0.;

    public void calibrate() {
    	
    	timer.start();
    	double t = Timer.getFPGATimestamp();
    	gyro.reset(); // Resets gyro angle to zero
    	Timer.delay(delayTime); // Delays calculations of Measurement to see the change in sensors
    	double gyroError = gyro.getAngle() / (Timer.getFPGATimestamp() - t);
    	gyroDriftRate = gyroError;
    	// Since the robot is not moving, we can assume that the current accelerometer measurements are biases
    	// But we average to eliminate outliers we may encounter
    	int samples = 100;
    	for(int i = 0; i <= samples; i++) {
    		accelerometerXBias += robotAccelerometer.getX(); // X Bias
    		accelerometerYBias += robotAccelerometer.getY(); // Y Bias
    		accelerometerZBias += robotAccelerometer.getZ(); // Z Bias (ALL OF THESE ARE USED IN getAccelerometerAxis(String axis)
    	}
    	accelerometerXBias /= (double)samples;
    	accelerometerYBias /= (double)samples;
    	accelerometerZBias /= (double)samples;
    	
    	setValid();
    	
    	
    }
    
    public void accumulate() {
    	if (!isValid()) {
    		calibrate();
    	}
    	double time = timer.get(),
    		   acceleration,
    		   forwardAccel = getAccelerometerAxis(forwardAccelAxis),
    		   sideAccel = getAccelerometerAxis(sidewaysAccelAxis),
    		   deltaT = time - lastTime;

    	gyroAngle = gyro.getAngle() - (gyroDriftRate*time); // Adjusts current gyro angle for its drift
    	acceleration = Math.sqrt(Math.pow(forwardAccel,2) + Math.pow(sideAccel,2)); // gets vector magnitude of 2D acceleration
    	velocity = acceleration*(deltaT); // v = at
    	distanceTravelled += 0.5*deltaT*velocity; // d = 0.5*a*t^2 || d = 0.5*vt
    	distanceTravelledY += distanceTravelled * Math.cos(Math.toRadians(gyroAngle));
    	distanceTravelledX += distanceTravelled * Math.sin(Math.toRadians(gyroAngle));
    	
    	lastTime = time;    	
    }
    
    private double getAccelerometerAxis(String axis) {
    	if (axis == "X") {
    		return (robotAccelerometer.getX() - accelerometerXBias)*GtoInches;
    	} else if (axis == "Y") {
    		return (robotAccelerometer.getY() - accelerometerYBias)*GtoInches;
    	} else if (axis == "Z") {
    		return (robotAccelerometer.getZ() - accelerometerZBias)*GtoInches;
    	}
    	return 0.;
    }
    public void setValid() {
    	validity = true;
    }
    
    public void setInvalid() {
    	validity = false;
    }
    
    public boolean isValid() {
    	return validity;
    }
    
    public double getVelocity() {
    	return velocity;
    }
    
    public double getDistanceTravelled() {
    	return distanceTravelled;
    }
    
    public double getDistanceTravelled(String axis) {
    	if (axis == "Y") {
    		return distanceTravelledY;
    	} else if (axis == "X") {
    		return distanceTravelledX;
    	}
    	return distanceTravelled;
    }
    
    public double getAngle() {
    	return gyroAngle;
    }
}

